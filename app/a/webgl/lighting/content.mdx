# Lighting

You may need to read the previous articles about [3D](/a/webgl/3d) and [varyings](/a/webgl/varyings) in order to
understand this one.

## Directional lighting

*Directional lighting* (or *diffuse lighting*) is the simplest form of lighting. It assumes that the light is coming
uniformly from one direction. One common use case of directional lighting is to emulate light from the sun.

If the direction that the light is traveling and the direction that a surface is facing are both known, it is
possible to determine the cosine of the angle between the two directions by taking the dot product. That value
represents the "brightness" of the light on that surface.

The direction that a surface is facing is represented by a unit vector called a *normal*.

```glsl
#version 300 es

in vec4 a_position;
in vec3 a_normal;

uniform mat4 u_matrix;

out vec3 v_normal;

void main() {
	gl_Position = u_matrix * a_position;
	v_normal = a_normal;
}
```

```glsl
#version 300 es

precision highp float;

in vec3 v_normal;

uniform vec4 u_color;

/*
Instead of taking the direction that the light is moving as
input, it is easier to take the position of the light
source (in other words, the direction to the light source).
*/
uniform vec3 u_reverseLightDirection;

out vec4 outColor;

void main() {
	/*
	Since v_normal is a varying, its value is interpolated.
	Therefore, it must be re-normalized to a unit vector.
	*/
	vec3 normal = normalize(v_normal);

	float light = dot(normal, u_reverseLightDirection);

	outColor = u_color;
	outColor.rgb *= light;
}
```

import DirectionalLightingStaticBrokenNormals from "./DirectionalLightingStaticBrokenNormals";

<DirectionalLightingStaticBrokenNormals style={{ width: "100%" }} />

Notice that although sides of the cube above are being lit properly, the light isn't changing when the cube rotates.
This is because the normals aren't being re-oriented like the positions are. Multiplying the normals by the object's
world matrix will have the desired effect. Note that this requires the world matrix and the view projection matrix to
be passed separately.

```glsl
#version 300 es

in vec4 a_position;
in vec3 a_normal;

uniform mat4 u_viewProjMat;
uniform mat4 u_worldMat;

out vec3 v_normal;

void main() {
	mat4 mat = u_viewProjMat * u_worldMat;

	gl_Position = mat * a_position;

	v_normal = mat3(u_worldMat) * a_normal;
}
```

import DirectionalLightingBrokenNormals from "./DirectionalLightingBrokenNormals";

<DirectionalLightingBrokenNormals style={{ width: "100%" }} />

One issue with the solution above is that the normals get skewed when the world matrix gets scaled. This can be fixed by using
the inverse transpose of the world matrix instead.

```glsl
#version 300 es

in vec4 a_position;
in vec3 a_normal;

uniform mat4 u_viewProjMat;
uniform mat4 u_worldMat;
uniform mat4 u_invTransWorldMat;

out vec3 v_normal;

void main() {
	mat4 mat = u_viewProjMat * u_worldMat;

	gl_Position = mat * a_position;

	v_normal = mat3(u_invTransWorldMat) * a_normal;
}
```

The example below doesn't look any different because the cube isn't being scaled, but it uses the world inverse transpose matrix
instead of just the world matrix.

import DirectionalLighting from "./DirectionalLighting";

<DirectionalLighting style={{ width: "100%" }} />

## Colored lighting

The light can be given a color by adding a color to the calculation.

```glsl
#version 300 es

precision highp float;

in vec3 v_normal;

uniform vec4 u_color;
uniform vec3 u_reverseLightDirection;
uniform vec4 u_lightColor;

out vec4 outColor;

void main() {
	vec3 normal = normalize(v_normal);

	vec3 light = u_lightColor.rgb
		* dot(normal, u_reverseLightDirection);

	outColor = u_color;
	outColor.rgb *= light;
}
```

import DirectionalLightingColored from "./DirectionalLightingColored";

<DirectionalLightingColored style={{ width: "100%" }} />

## Ambient lighting

*Ambient lighting* is lighting that is applied equally to all triangles, regardless of their normal vector. This is used to set a
"minimum" brightness to ensure that nothing in the scene is too dark.

```glsl
#version 300 es

precision highp float;

in vec3 v_normal;

uniform vec4 u_color;
uniform vec3 u_reverseLightDirection;
uniform vec4 u_lightColor;
uniform vec4 u_ambientLightColor;

out vec4 outColor;

void main() {
	vec3 normal = normalize(v_normal);

	vec3 directionalLight = u_lightColor.rgb
		* dot(normal, u_reverseLightDirection);

	vec3 ambientLight = u_ambientLightColor.rgb;

	outColor = u_color;
	outColor.rgb *= directionalLight + ambientLight;
}
```

import AmbientDirectionalLightingColored from "./AmbientDirectionalLightingColored";

<AmbientDirectionalLightingColored style={{ width: "100%" }} />

## Point lighting

This article is a work-in-progress. In the meantime, consider reading these other articles about the same topic:

- [Lighting and shading](https://xem.github.io/articles/webgl-guide.html#3e).
- [Point lighting](https://webgl2fundamentals.org/webgl/lessons/webgl-3d-lighting-point.html).

## Spot lighting

This article is a work-in-progress. In the meantime, consider reading these other articles about the same topic:

- [Lighting and shading](https://xem.github.io/articles/webgl-guide.html#3e).
- [Spot lighting](https://webgl2fundamentals.org/webgl/lessons/webgl-3d-lighting-spot.html).

## Specular lighting

This article is a work-in-progress. In the meantime, consider reading these other articles about the same topic:

- [Lighting and shading](https://xem.github.io/articles/webgl-guide.html#3e).

The next article is about [shadows](/a/webgl/shadows).
