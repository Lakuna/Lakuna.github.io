# Crash Course: Computer Vision

This is the companion article for my presentation about computer vision at Evanston Township High School. This presentation is part of the requirements for my participation in NASA's [Lunabotics Challenge](https://www.nasa.gov/learning-resources/lunabotics-challenge/).

## Lunabotics 2024 Results

**(Edit 5/20/2024)**

UIC won the following awards for Lunabotics 2024:

- First place at the UCF semifinals.
- Fifth place for autonomy[^1].
- The judges' innovation award.
- A special recognition for mission control operation.

[^1]: One dead run reduced our score, without which we likely would have gotten first place.

Our UCF runs were livestreamed [here](https://youtu.be/YM1kDA4uBKE?t=36416s) and [here](https://youtu.be/5QjJYCF66dE?t=8748).

## Computer Vision

According to [Wikipedia](https://en.wikipedia.org/wiki/Computer_vision):

> "Computer vision is an interdisciplinary field that deals with how computers can be made to gain high-level understanding from digital images or videos."

In other words, computer vision is the field that deals with making computers see things. It is called _interdisciplinary_ because two disciplines are involved: scientists and engineers. Scientists are concerned with the theory behind artificial systems that extract information from images. Engineers apply those theories to automate tasks that the human visual system can do.

Some of these tasks include:

- _Scene reconstruction_: building 3D models from images and videos.
- _Object and event detection_: detecting objects and events in images and videos.
- _Activity and object recognition_: recognizing and classifying activities and objects in images and videos.
- _Video tracking_: tracking the motion of an object through a video.
- _3D pose estimation_: determining the positions of a person's limbs in an image or video.
- _Image restoration_: improving the quality of images.

Since there are unlimited possible images and computers have a limited amount of memory, it is impossible to tell a computer exactly how it should perceive every image. For this reason, it is necessary to use _machine learning_ to teach the computer how to make inferences. Machine learning is the use of an algorithm whose performance improves over time as it is exposed to more data. This is what people are typically referring to when they talk about _artificial intelligence_.

### Scene Reconstruction

import CustomImage from "#CustomImage";
import sceneReconstruction from "./scene-reconstruction.png";

<CustomImage
	src={sceneReconstruction}
	alt="Scene reconstruction example."
	style={{ width: "100%", height: "auto" }}
	placeholder="blur"
/>

This image is from the [Stanford Computer Graphics Laboratory](https://graphics.stanford.edu/~mdfisher/SceneReconstruction.html). Computers understand shapes as meshes of triangles. This image shows how the computer maps a generated texture onto the mesh of triangles to create a 3D representation of the scene.

### Object Recognition and Video Tracking

import YoutubeVideo from "#YoutubeVideo";

<YoutubeVideo src="VWdJ4BCtam8" />

This video serves as an introduction to the [Jetson Orin Nano](https://www.nvidia.com/en-us/autonomous-machines/embedded-systems/jetson-orin/), which is the computer that will control our Lunabotics robot. The video contains several examples that demonstrate object detection and recognition and video tracking.

### 3D Pose Estimation

The video that is shown in the presentation is from the [National Center for Biotechnology Information](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4433345/). Notice that the man in the video is not wearing any tracking devices, so the pose estimation must be entirely based on visual input.

### Image Restoration

import imageRestoration from "./image-restoration.png";

<CustomImage
	src={imageRestoration}
	alt="Image restoration example."
	style={{ width: "100%", height: "auto" }}
	placeholder="blur"
/>

This image was restored using a project called [DeOldify](https://github.com/jantic/DeOldify). The image is "Migrant Mother," taken by Dorothea Lange in 1936.

### Computer Vision and the Lunabotics Challenge

import artemisArenaLayout from "./artemis-arena-layout.png";

<CustomImage
	src={artemisArenaLayout}
	alt="Artemis arena layout."
	style={{ width: "100%", height: "auto" }}
	placeholder="blur"
/>

This image from the [Lunabotics 2024 guidebook](https://www.nasa.gov/wp-content/uploads/2023/09/a-lunabotics-2024-guidebook-draft-ver-2.0-09.12.2023.pdf) shows an example layout of the Artemis arena. Our robot will start in the starting zone. Its goal will be to excavate as much regolith as possible from the excavation zone and dump it in the berm in the construction zone. In order to do so, it will perform [SLAM](https://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping) to navigate around rocks and craters. If we are able to fully automate the robot, we will score a ton of points in the competition in May.

## Python

The following crash course in Python is designed only to cover the parts of the Python language that will be needed for the basic computer vision projects later on. In case you're interested in learning more, this companion article will mention other language features that you may want to look up by yourself.

_Python_ is a high-level, general-purpose scripting language. _High-level_ means that it abstracts away many of the details that a low-level language wouldn't, which makes it much easier to learn. In fact, Python is the most popular first programming language for new programmers to learn. _General-purpose_ means that it can be used to write all kinds of programs, such as web development, game development, robotics, computer vision, machine learning, and more. It is called a _scripting language_ because it is dynamic; more on that later. Because it is a scripting language, Python programs can also be called _scripts_.

The [TIOBE index](https://www.tiobe.com/tiobe-index/) is a ranking of the popularity of programming languages. Python has been near the top for decades (11th place or higher since 2004), and it is now considered one of the "big four" programming languages, along with C, C++, and Java. It has also won the "Programming Language of the Year" award five times.

### Getting Started

If you'd like to download Python on your own computer, you can do so from [its website](https://www.python.org/). If you choose to do so, I would also highly recommend downloading an integrated development environment (IDE) to program in, such as [Visual Studio Code](https://code.visualstudio.com/).

If you don't want to download Python, the best way to use it online is through [Replit](https://repl.it/). You will need to make an account to do this.

### "Hello, world!"

It is a tradition among programmers for the first program you write in a new language to print `Hello, world!` to the standard output (console or terminal). To do so in Python, write the following line of code:

```python
print("Hello, world!")
```

Everything inside of the quotation marks is called a _string_, which is a list of characters. You can try changing it to print out other phrases.

Since Python is a [dynamic programming language](https://en.wikipedia.org/wiki/Dynamic_programming_language), we do not need to compile this program in order to run it. Instead, a program called an _interpreter_ runs the code as-is. If you're using Python on your own computer, try saving this file as `hello.py`, then run the interpreter with the following command in your terminal:

```bash
python hello.py
```

### Procedural Programming

Python is a [procedural programming language](https://en.wikipedia.org/wiki/Procedural_programming), which means that Python programs are composed of a series of procedures that are executed sequentially (one at a time from top to bottom). In the following code snippet, the words `One`, `Two`, and `Three` will be printed to the standard output on different lines in that order.

```python
print("One")
print("Two")
print("Three")
```

### Imperative Programming

Procedural programming is a type of [imperative programming](https://en.wikipedia.org/wiki/Imperative_programming). Imperative programs are composed of a series of statements that change the program's state. _Statements_ and _procedures_ refer to the same thing. For example, `print("Hello, world!")` is a statement.

Another type of statement is an _assignment_ to a _variable_. Variables are values that vary. The previous examples printed _literals_, which are values that don't vary. By using the assignment operator, `=`, it is possible to assign a value to a variable. Variables can be printed just like literals:

```python
my_variable = "Hello, world!"
print(my_variable)
```

The value of a variable can be changed by using the assignment operator again:

```python
my_variable = "One"
my_variable = "Two"
print(my_variable)
```

In this example, the value of the variable called `my_variable` is set to `"One"`, then it is replaced with `"Two"`. When we then print `my_variable`, the output is `Two`.

### Arithmetic

The arithmetic operators, `+`, `*`, `-`, and `/`, can be used to perform addition, multiplication, subtraction, and division, respectively.

```python
print(3 + 3)
print(3 * 3)
print(3 - 3)
print(3 / 3)
```

Parentheses can be used to control the order of operations:

```python
print(3 * (3 + 3))
```

### Lists

In addition to strings and numbers, variables can also hold _lists_ of values. Lists are created by surrounding comma-separated values with square brackets. The values inside of a list can be accessed by putting square brackets that contain the index of the value after the list. **Lists are zero-indexed**, meaning that the first value is at index zero.

```python
my_list = ["Zero", "One"]
print(my_list[0])
print(my_list[1])
```

Lists can hold any type of value, including other lists!

```python
my_list = ["Zero", 1, 2, [3, 4, 5]]
print(my_list[3][0])
```

In the example above, `my_list` has another list at index `3`, so we can use yet another pair of square brackets to access elements inside of the inner list.

### Structured Programming

[Structured programming](https://en.wikipedia.org/wiki/Structured_programming) improves the clarity of programs through the use of conditionals, loops, blocks, and functions. _Blocks_ are sections of code that are executed together. Examples will follow.

#### Conditionals

_Conditionals_ are statements that execute a block of code depending on a given condition. In Python, every value is either _truthy_ or _falsy_. Empty strings, empty lists, the number `0`, and the literal value `False` are all falsy; almost every other value is truthy.

`True` and `False` are called _Boolean_ values. Boolean values can be created by using the comparison operators: `==` (equals), `>` (greater than), `<` (less than), `>=` (greater than or equal to), `<=` (less than or equal to), and `!=` (not equal to).

`if` statements execute a block of code if the given condition is truthy:

```python
if 1 < 2:
	print("Correct")
```

Because `1` is less than `2`, the comparison `1 < 2` becomes the literal value `True`, so the `print` statement is executed. Notice that the `print` statement is indented from the `if` statement. In Python, indentation is used to delineate blocks.

```python
if 1 < 2:
	print("One")
	print("Two")

if 1 > 2:
	print("Three")
	print("Four")

print("Five")
```

In the example above, `One` and `Two` will be printed because `1` is less than `2`. `Three` and `Four` will not be printed because `1` is not greater than `2`. `Five` will be printed because it isn't inside of an `if` statement at all.

`if` statements are an example of [control flow](https://en.wikipedia.org/wiki/Control_flow), which is the order in which individual statements in an imperative program are executed. Other control flow statements include `elif` ("else if") and `else` statements.

```python
if 1 > 2:
	print("One")
elif 1 < 2:
	print("Two")
else:
	print("Three")
```

In this example, since `1 > 2` is `False`, the script will then continue on to the next conditional. Then, since `1 < 2` is `True`, it will print `Two`. After that, since one of the conditions was met, the `else` block will be skipped. If both of the previous conditions had been `False`, the `else` block would be triggered. It is possible to chain together multiple `elif` blocks before an `else` block.

It is also possible to put blocks inside of other blocks. This is called _nesting_.

```python
if 1 < 2:
	print("One")

	if 1 > 2:
		print("Two")

	print("Three")
```

In this example, `One` will be printed because `1 < 2` is `True`. Then, because `1 > 2` is `False`, the second `print` statement will be skipped. Pay attention to the indentation, though: `Three` will be printed because it is only inside of the first conditional statement.

#### Loops

_Loops_ are used to repeat a block. `for` loops execute a block once for each value in a list.

```python
my_list = [0, 1, "Two", True, [4, 6, 8]]
for my_value in my_list:
	print(my_value)
```

In this example, the `print` statement will be executed once for each value in `my_list`. `my_value` will contain that value each time. On the first iteration, `my_value` will be `0`, on the second, it will be `1`, on the third, it will be `"Two"`, and so on.

`while` loops execute a block while the given condition remains truthy. They are similar to `if` statements that happen multiple times.

```python
i = 0
while i < 5:
	print(i)
	i = i + 1
```

In the example above, each number from `0` through `4` will be printed because `i` gets `1` larger at the end of each iteration. Then, when `i` becomes `5`, `i < 5` will be `False` and the loop will stop.

`continue` and `break` statements are used to further control loops. `continue` causes the loop to immediately proceed to the next iteration, and `break` causes the loop to immediately exit entirely.

```python
my_list = [0, 0, 1, 0, 0, 0, 2, 0, 0, 3, 4, 0, 0, 5]
for my_value in my_list:
	if my_value == 0:
		continue

	print(my_value)
```

In this example, each integer from `1` through `5` will be printed. `0` will never be printed, because if `my_value` is `0`, the iteration will be skipped before arriving at the `print` statement.

```python
i = 0
while True:
	if i > 5:
		break

	print(i)
	i = i + 1
```

In this example, each integer from `1` through `5` will be printed. `True` will never be falsy, so the loop would continue forever if it weren't for the `break` statement.

#### Functions

_Functions_ are subroutines, which are reusable blocks. Functions can be defined with the `def` keyword, after with point they can be _called_ (executed) from anywhere by putting a pair of parentheses after the function's name.

```python
def my_function():
	print("One")
	print("Two")

my_function()
my_function()
```

In this example, the lines `One`, `Two`, `One`, and `Two` will be printed, in that order.

Functions can also take _arguments_ (parameters) to change what they do. Giving a value to a function is called _passing_ that value to the function.

```python
def print_twice(my_argument):
	print(my_argument)
	print(my_argument)

print_twice("One")
print_twice("Two")
```

In this example, the lines `One`, `One`, `Two`, and `Two` will be printed, in that order. You might notice that `print` itself is a function. `print` is one of many functions that is automatically included in every Python program from the _Python standard library_. Other functions from the standard library include `len`, which determines the length of a list, and `str`, which _casts_ (converts) any value into a string.

The `return` keyword is similar to `break`, but it is used for functions instead of loops. Executing a `return` statement from within a function causes that function to immediately exit, and the script will continue from where it was called.

```python
def print_once(my_argument):
	print(my_argument)
	return
	print(my_argument)

print_once("Hello, world!")
```

In this example, only one line will be printed because the function returns before it gets to the second `print` statement.

The `return` keyword can also be used to make a function `return` a value to be used elsewhere in the script. For example:

```python
def multiply_by_five(my_number):
	return my_number * 5

print(multiply_by_five(3))
```

In this example, `3` is passed to `multiply_by_five`. Then, inside of `multiply_by_five`, the value of `my_number` will be `3`. `multiply_by_five` returns `3 * 5`, which is then printed from outside of the function.

### Importing Code

Code from other files and libraries can be imported with the `import` keyword.

```python
import cv2
```

Imagine that you have two files in the same directory. The first, `one.py`, contains the following code:

```python
my_variable = "Hello, world!"
```

The second file, `two.py`, can then import the variables and functions from `one.py` as follows:

```python
import one
print(one.my_variable)
```

The `.` operator is used to access a variable or function that "belongs to" an imported file or library.

## OpenCV

[OpenCV](https://opencv.org/) is an open-source computer vision libray. It provides functions that allow us to manipulate images. If you're using Python on your own computer, install OpenCV using a terminal:

```bash
pip install opencv-python
```

Then, import it in any Python file with `import cv2`.

If you're using Replit, you'll need to use [the official Python OpenCV template](https://repl.it/@scottatreplit/Python-OpenCV).

### Image Manipulation

Images are stored as columns of rows of pixels. Each pixel is stored as a list of three numbers representing the red, green, and blue values of the pixel, respectively. In other words, images are lists of lists of lists.

Images can be loaded using the `imread` function, and they can be saved using the `imwrite` function. For example, we can copy an image called `a.png` to a file called `b.png` like this:

```python
import cv2

my_image = cv2.imread("a.png")
cv2.imwrite("b.png", my_image)
```

If we want to modify the image, we can do so in between the calls to `imread` and `imwrite`.

We can iterate over the pixels in an image like this:

```python
for row in my_image:
	for pixel in row:
		do_something()
```

### Image Processing

Depending on what we want to do with an image, it can be useful to modify that image in some way ahead of time. For example, if we are trying to detect objects in order to avoid them, we only need to see their outlines - color information is irrelevant and might make it harder for an algorithm to learn.

If we want to make an image grayscale, we can do so by setting the red, green, and blue values of each pixel to the _luminance_ of that pixel. Luminance is calculated as follows:

$$
l=0.2126r+0.7152g+0.0722b
$$

Where $l$ is the luminance, $r$ is the red value, $g$ is the green value, and $b$ is the blue value.

Putting it all together, we get this script to convert an image `a.png` into a grayscale version `b.png`:

```python
import cv2

my_image = cv2.imread("a.png")

for row in my_image:
	for pixel in row:
		red = pixel[0]
		green = pixel[1]
		blue = pixel[2]
		luminance = red * 0.2126 + green * 0.7152 + blue * 0.0722
		pixel[0] = luminance
		pixel[1] = luminance
		pixel[2] = luminance

cv2.imwrite("b.png", my_image)
```

Alternatively, we can just use OpenCV's built-in function for doing the same thing:

```python
import cv2

my_image = cv2.imread("a.png")
my_image = cv2.cvtColor(my_image, cv2.COLOR_RGB2GRAY)
cv2.imwrite("b.png", my_image)
```

Once an image has been converted to grayscale, we can perform a further operation called _thresholding_ to convert it to black and white.

```python
import cv2

my_image = cv2.imread("a.png")
my_image = cv2.cvtColor(my_image, cv2.COLOR_RGB2GRAY)

for row in my_image:
	for pixel in row:
		luminance = pixel[0]
		if luminance > 127:
			pixel[0] = 255
			pixel[1] = 255
			pixel[2] = 255
		else:
			pixel[0] = 0
			pixel[1] = 0
			pixel[2] = 0

cv2.imwrite("b.png", my_image)
```

Again, OpenCV has a built-in function for performing the same action:

```python
import cv2

my_image = cv2.imread("a.png")
my_image = cv2.cvtColor(my_image, cv2.COLOR_RGB2GRAY)
_, my_image = cv2.threshold(my_image, 127, 255, cv2.THRESH_BINARY)
cv2.imwrite("b.png", my_image)
```

_Edge detection_ - that is, finding outlines - is a more complex process because it requires knowledge of surrounding pixels. For operations like this, we use a _convolution kernel_ to modify each pixel based on the pixels around it. A convolution kernel is a matrix that represents the weight of each surrounding pixel towards the product. For example, in order to blur an image, you could use a convolution kernel that gives equal weight to all of the surrounding pixels:

$$
\begin{bmatrix}\frac{1}{9}&\frac{1}{9}&\frac{1}{9}\\\frac{1}{9}&\frac{1}{9}&\frac{1}{9}\\\frac{1}{9}&\frac{1}{9}&\frac{1}{9}\end{bmatrix}
$$

OpenCV provides the `blur` function for this purpose.

```python
import cv2

my_image = cv2.imread("a.png")
my_image = cv2.blur(my_image, (5, 5))
cv2.imwrite("b.png", my_image)
```

import imageBlur from "./image-blur.jpg";

<CustomImage
	src={imageBlur}
	alt="Image blur."
	style={{ width: "100%", height: "auto" }}
	placeholder="blur"
/>

A similar function, `GaussianBlur`, is designed to be effective at removing [Gaussian noise](https://en.wikipedia.org/wiki/Gaussian_noise) from an image.

```python
import cv2

my_image = cv2.imread("a.png")
my_image = cv2.GaussianBlur(my_image, (5, 5), 0)
cv2.imwrite("b.png", my_image)
```

We can also use convolution kernels to calculate the _intensity gradient_ of an image. The intensity gradient is a measure of how much of a difference there is from one pixel to the next.

import imageGradients from "./image-gradients.jpg";

<CustomImage
	src={imageGradients}
	alt="Image gradients."
	style={{ width: "100%", height: "auto" }}
	placeholder="blur"
/>

This image is from [the OpenCV Python Image Gradients tutorial](https://docs.opencv.org/3.4/d5/d0f/tutorial_py_gradients.html). It demonstrates three different types of intensity gradients: Laplacian, Sobel X, and Sobel Y. Each uses a different convolution kernel. For example, the following convolution kernel can be used to calculate the Laplacian gradient of an image:

$$
\begin{bmatrix}0&1&0\\1&-4&1\\0&1&0\end{bmatrix}
$$

Using blurring and intensity gradients, we can perform [Canny edge detection](https://en.wikipedia.org/wiki/Canny_edge_detector) as follows:

1. Perform Gaussian blurring in order to remove Gaussian noise from the image. This makes it less likely that we will detect a noise artifact as an edge.
2. Determine the intensity gradient of the image. This is typically done in two parts - once for horizontal edges, and once for vertical edges.
3. Remove pixels that aren't local maxima (can't possibly be edges).
4. Hysteresis thresholding: remove pixels that can't be edges (based on a minimum threshold), mark pixels that must be edges (based on a maximum threshold), and determine which pixels that might be edges are actually edges (based on whether they touch other edge pixels).

Again, OpenCV provides a function for this:

```python
import cv2

my_image = cv2.imread("a.png")
my_image = cv2.Canny(my_image, 100, 200)
cv2.imwrite("b.png", my_image)
```

import edgeDetection from "./edge-detection.jpg";

<CustomImage
	src={edgeDetection}
	alt="Edge detection example."
	style={{ width: "100%", height: "auto" }}
	placeholder="blur"
/>

Now that we've detected all of the edges, we can finally detect the _contours_. Contours are curves that join all of the continuous points with the same intensity. They can be thought of as the subset of edges that outline things. Conceptually, contours can be found via the following process:

1. Perform edge detection on an image.
2. Create an undirected graph of all of the edge points.
3. Search the graph for cycles. Those cycles are contours.

OpenCV provides another function for this:

```python
import cv2
import numpy
import random

my_image = cv2.imread("a.png")
edge_image = cv2.Canny(my_image, 100, 200)

contours, hierarchy = cv2.findContours(edge_image, cv2.RETR_TREE,
                                       cv2.CHAIN_APPROX_SIMPLE)

# Create a blank image to draw the contours in.
contour_image = numpy.zeros(my_image.shape)

# Draw each contour with a different color.
for i in range(len(hierarchy[0])):
    red = random.random() * 0xFF
    green = random.random() * 0xFF
    blue = random.random() * 0xFF
    color = (red, green, blue)
    cv2.drawContours(contour_image, contours, i, color)

cv2.imwrite("b.png", contour_image)
```

import contourDetection from "./contour-detection.png";

<CustomImage
	src={contourDetection}
	alt="Contour detection example."
	style={{ width: "100%", height: "auto" }}
	placeholder="blur"
/>
