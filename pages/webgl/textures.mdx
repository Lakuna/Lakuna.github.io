---
title: WebGL Textures
description: An introduction to using textures in WebGL.
---
# Textures

You may need to read the previous articles about
[attributes](/webgl/attributes),
[uniforms](/webgl/uniforms), and
[varyings](/webgl/varyings) in order to understand this
one.

A *texture* is an array of data that can be randomly
accessed in a shader program. Textures are mostly used to
store image data.

In a shader, a *sampler* uniform is used to reference a
texture. The `texture` function is used to get data out of
a texture at the given *texture coordinates*. Texture
space is a coordinate system in the interval $[0,1]$ from
left to right and from the first pixel on the first line
to the last pixel on the last line.

```glsl
#version 300 es

precision highp float;

in vec2 v_texcoord;

uniform sampler2D u_texture;

out vec4 outColor;

void main() {
	outColor = texture(u_texture, v_texcoord);
}
```

In order to access a texture in WebGL, a texture object
must be created and bound to an appropriate binding point
with the WebGL API (much like a buffer).

```js
const texture = gl.createTexture();

gl.bindTexture(gl.TEXTURE_2D, texture);

// Fill the texture with one blue pixel as a placeholder.
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA,
	gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));

/*
Create an image, make it load data, and put it into the
texture once it's ready.
*/
const image = new Image();
image.addEventListener("load", () => {
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,
		gl.UNSIGNED_BYTE, image);
});
image.crossOrigin = ""; // CORS
image.src = "https://www.lakuna.pw/images/" +
	"webgl-example-texture.png";
```

Instead of taking a texture as the value of a sampler
uniform directly, WebGL expects a *texture unit*
representing the texture.

```js
// Select a texture unit.
gl.activeTexture(gl.TEXTURE0);

// Assign a texture to the texture unit.
gl.bindTexture(gl.TEXTURE_2D, texture);

// Pass the texture unit to the sampler uniform.
gl.uniform1i(imageUniformLocation, 0);
```

Umbra handles texture units automatically.

```js
const texture = new Texture2D({
	gl,
	pixels: new Uint8Array([0xFF, 0x00, 0xFF, 0xFF]),
	width: 1,
	height: 1
});

const image = new Image();
image.addEventListener("load", () => {
	texture.pixels = image;
	texture.width = undefined;
	texture.height = undefined;
	texture.update();
});
image.crossOrigin = "";
image.src = "https://www.lakuna.pw/images/" +
	"webgl-example-texture.png";

program.uniforms.get("u_texture").value = texture;
```

import UmbraTextures from "../../assets/components/umbra/UmbraTextures";

<UmbraTextures style={{ width: "100%", border: "1px solid black" }} />

Check out the artist of the example textures on
[her website](https://www.xanycki.art/).

## Texture parameters

Certain parameters of a texture can be modified with the
WebGL API via the `texParameteri` function.

```js
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S,
	gl.CLAMP_TO_EDGE);
```

As with other situations where binding points are
necessary, Umbra uses an object-oriented approach to
texture parameters.

```js
texture.wrapSFunction = TextureWrapFunction.CLAMP_TO_EDGE;
```

WebGL can be told what to do when supplied texture
coordinates outside of the interval $[0,1]$ in the $s$ and
$t$ directions with the `TEXTURE_WRAP_S` and
`TEXTURE_WRAP_T` texture parameters, respectively.

- `REPEAT` is the default functionality. It makes the
texture repeat in the given direction.
- `CLAMP_TO_EDGE` makes the texture not repeat at all.
- `MIRRORED_REPEAT` makes the texture repeat, but flips
the texture across the corresponding axis for each
repetition.

import UmbraTextureParameters from "../../assets/components/umbra/UmbraTextureParameters";

<UmbraTextureParameters style={{ width: "100%", border: "1px solid black" }} />

A *mipmap* is a collection of smaller versions of a texture
that is used to render a texture at different sizes. A
*mip* is one level of a mipmap. The way that the mipmap is
generated can be specified with the `TEXTURE_MIN_FILTER`
and `TEXTURE_MAG_FILTER` parameters. The minification
filter (which corresponds to the former) is used when
drawing anything smaller than the largest mip, and the
magnification filter (which corresponds to the latter) is
used when drawing anything larger than the largest mip.

- `NEAREST` chooses one pixel from the largest mip.
- `LINEAR` chooses four pixels from the largest mip and
blends them.
- `NEAREST_MIPMAP_NEAREST` chooses the best mip, then picks
one pixel from that mip.
- `LINEAR_MIPMAP_NEAREST` chooses the best mip, then blends
four pixels from that mip.
- `NEAREST_MIPMAP_LINEAR` chooses the best two mips, then
chooses one pixel from each and blends them.
- `LINEAR_MIPMAP_LINEAR` chooses the best two mips, then
chooses four pixels from each and blends them.

Since the magnification filter is used when drawing larger
than the largest mip, it can only be `NEAREST` or `LINEAR`.

**In order for a texture to render, it must be *texture
complete***. A texture is texture complete if it either
only reads the first mip (i.e. uses `NEAREST` or `LINEAR`
as its minification filter) or has a complete mipmap. The
easiest way to generate a complete mipmap is with the WebGL
API's `generateMipmap` function.

```js
gl.generateMipmap(gl.TEXTURE_2D);
```

Umbra textures have an equivalent method, but it is
automatically executed when necessary.

import UmbraMipmaps from "../../assets/components/umbra/UmbraMipmaps";

<UmbraMipmaps style={{ width: "100%", border: "1px solid black" }} />

## Texture atlases

A *texture atlas* is a texture that contains multiple
images. This method has a few advantages, such as keeping
the shader that uses it simple and reducing the number of
draw calls required to draw multiple images.

import UmbraTextureAtlases from "../../assets/components/umbra/UmbraTextureAtlases";

<UmbraTextureAtlases style={{ width: "100%", border: "1px solid black" }} />
