import MdxArticleLayout from "../../components/MdxArticleLayout.tsx";
import CodePen from "../../components/CodePen.tsx";
import styles from "../../styles/mdx-article.module.scss";
import "katex/dist/katex.min.css";

# Textures

A *texture* is an array of data that can be randomly accessed in a shader program.
Most commonly, textures are used to store image data.

In a shader, a *sampler* uniform is used to reference a texture.
The `texture` function is used to get data out of the texture at the given *texture coordinate*.
Texture coordinates are coordinates which range from `0` (bottom left) to `1` (top right) in both directions.
Note that *image coordinates* start at the top left corner and extend to the image's size in pixels, so texture coordinates may appear upside-down from the expected result.

```glsl
#version 300 es

precision highp float;

// Get texture coordinates from the fragment shader.
in vec2 v_texcoord;

// A sampler2D is used to reference normal 2D textures.
uniform sampler2D u_texture;

out vec4 outColor;

void main() {
  // Return the value of the texture at the given position.
  outColor = texture(u_texture, v_texcoord);
}
```

In order to access a texture in WebGL, a texture object must be created with the WebGL API.

```js
const texture = gl.createTexture();
```

The texture must be supplied data.
This data can take many forms, such as HTML images or color data.

```js
// Bind the texture to modify it.
gl.bindTexture(gl.TEXTURE_2D, texture);

// 1x1 blue pixel.
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));

// Image from URL.
const image = new Image();
image.addEventListener("load", () => {
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.generateMipmap(gl.TEXTURE_2D);
});
image.crossOrigin = "";
image.src = "https://www.xanycki.art/images/slideshow/1.png";
```

Instead of passing a texture to the sampler uniform directly, we assign it a *texture unit* to be passed in its place.
With just the WebGL API, that looks like this:

```js
// Select a texture unit.
gl.activeTexture(gl.TEXTURE0);

// Assign a texture to the texture unit.
gl.bindTexture(gl.TEXTURE_2D, texture);

// Set the uniform to the texture unit.
gl.uniform1i(imageUniformLocation, 0);
```

Umbra handles texture units automatically.

```js
const texture = new Texture2D(gl, new Uint8Array([0, 0, 255, 255]));
texture.width = 1;
texture.height = 1;

program.uniforms.get("u_texture").value = texture;
```

<CodePen slugHash="MWVYpJz" className={styles["full-bleed"]} />

## Texture parameters

Certain parameters of a texture can be modified using `gl.texParameteri`.

```js
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
```

As with other situations where bind points are necessary, Umbra takes a more object-oriented approach.

```js
texture.wrapSFunction = TextureWrapFunction.CLAMP_TO_EDGE;
```

WebGL can be told what to do when supplied texture coordinates outside of the normal range with the `TEXTURE_WRAP_S` and `TEXTURE_WRAP_T` parameters (which define functionality in the S and T directions, respectively).

- `REPEAT` is the default functionality. It makes the texture repeat in the given direction.
- `CLAMP_TO_EDGE` makes the texture not repeat at all (the last pixel is used forever).
- `MIRRORED_REPEAT` makes the texture repeat, but mirrors each repetition.

<CodePen slugHash="abYBbvX" className={styles["full-bleed"]} />

A mipmap is a collection of smaller versions of a texture that is used to render a texture at different sizes.
Without a mipmap, textures can only be drawn at the exact size of the source texture.
A *mip* is one level of a mipmap.
The way that the *mipmap* is generated can be specified through the `TEXTURE_MIN_FILTER` and `TEXTURE_MAG_FILTER` parameters.
The former is the setting used when drawing anything smaller than the largest mip, and the latter is used when drawing anything larger than the largest mip.

- `NEAREST` chooses one pixel from the biggest mip.
- `LINEAR` chooses four pixels from the biggest mip and blends them.
- `NEAREST_MIPMAP_NEAREST` chooses the best mip, then picks one pixel from that mip.
- `LINEAR_MIPMAP_NEAREST` chooses the best mip, then blends four pixels from that mip.
- `NEAREST_MIPMAP_LINEAR` chooses the best two mips, then chooses one pixel from each and blends them.
- `LINEAR_MIPMAP_LINEAR` chooses the best two mips, then chooses four pixels from each and blends them.

Since the magnification filter is used when drawing larger than the largest mip, only `NEAREST` and `LINEAR` can be used.
Since `NEAREST` and `LINEAR` only ever use the largest mip, it is not necessary to generate a mipmap to use them.

In order for a texture to render, it must be *texture complete*.
In order for a texture to be texture complete, it must either only access the first mip (use the `NEAREST` or `LINEAR` minification filter) or have a complete mipmap.

<CodePen slugHash="PoRboJm" className={styles["full-bleed"]} />

## Texture atlases

A *texture atlas* is when multiple images are put into one texture.
This approach has a few advantages, such as keeping the shader simple and reducing the number of draw calls required to draw multiple images.

## Data textures

{/*
  https://webgl2fundamentals.org/webgl/lessons/webgl-3d-textures.html
  https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html
*/}

## Images

{/*
  https://webgl2fundamentals.org/webgl/lessons/webgl-3d-textures.html
  https://webgl2fundamentals.org/webgl/lessons/webgl-cors-permission.html
*/}

## Texture mapping

{/*
  https://webgl2fundamentals.org/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html
  https://webgl2fundamentals.org/webgl/lessons/webgl-planar-projection-mapping.html
*/}

Next: [Framebuffers](/webgl/framebuffers)

export default function applyLayout({ children }) { return (<MdxArticleLayout>{children}</MdxArticleLayout>); }

export async function getStaticProps() {
  return {
    props: {
      title: "Textures",
      description: "An introduction to using textures in WebGL."
    }
  };
}
