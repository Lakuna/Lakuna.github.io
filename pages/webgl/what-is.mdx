import MdxArticleLayout from "../../components/MdxArticleLayout.tsx";
import CodePen from "../../components/CodePen.tsx";
import styles from "../../styles/mdx-article.module.scss";

# What is WebGL?

*WebGL* is a *rasterization engine*.
That means that it draws *primitives* (points, lines, and triangles) using pixels.
That is all that it can do.
Using WebGL to draw complex scenes is up to the developer.

WebGL is based on *OpenGL ES*.

## Shaders

WebGL runs on the GPU, so developers need to provide it code that can run on the GPU.
That code is supplied in the form of pairs of functions called *shaders*.
Each pair of shaders contains one *vertex shader* and one *fragment shader*.
Collectively, the pair of shaders is called a *shader program*.

Shaders are written in a strictly-typed C-like language called *GLSL*.

Each shader fulfills a different purpose:

- The vertex shader is run once for each vertex in the shape being drawn; it computes the position of that vertex and outputs it as a *clip-space coordinate*.
Clip-space coordinates are a coordinate system that goes from `-1` to `+1` in every direction, regardless of the size of the viewport.
- Once the vertex shader has been run the proper number of times for the type of primitive being drawn (such as 3 for triangles), WebGL *rasterizes* (draws with pixels) that primitive.
The fragment shader is run once for each *fragment* (pixel) in the primitive being rasterized; it computes the color of that fragment.

The fragments from the fragment shader constitute a bitmap image stored in a *color buffer*, which is then displayed on a canvas.

A minimal vertex shader looks like this:

```glsl
#version 300 es

// Every shader has a main function to be executed.
void main() {
  // Setting the special "gl_Position" variable is how the vertex shader outputs clip-space coordinates.
  gl_Position = vec4(0, 0, 0, 1);
}
```

A minimal fragment shader looks like this:

```glsl
#version 300 es

// Must set a default precision for fragment shaders.
precision highp float;

// Must declare an output variable for fragment shaders.
out vec4 outColor;

void main() {
  // Setting the output variable is how the fragment shader outputs colors.
  outColor = vec4(0, 0, 0, 1);
}
```

**The first line of every WebGL2 shader must be "#version 300 es"**.
This line must come before even comments and whitespace.
It tells the WebGL API that we're writing a program in the GLSL ES 3.00 language, which is required for WebGL2.

## The WebGL API

The [WebGL API](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) is how developers interact with WebGL through JavaScript.
It can be accessed through the rendering context on an HTML canvas element.

```html
<!-- Create the canvas in HTML. -->
<canvas></canvas>
```

```js
// Get the canvas in JavaScript.
const canvas = document.querySelector("canvas");

// Get the WebGL rendering context of the canvas.
const gl = canvas.getContext("webgl2");
```

The WebGL API can be used to compile shader programs.

```js
// Put the vertex shader source code into a string.
const vertexShaderSource =
`#version 300 es

void main() {
  gl_Position = vec4(0, 0, 0, 1);
}`;

// Create the vertex shader.
const vertexShader = gl.createShader(gl.VERTEX_SHADER);

// Assign the vertex shader source code to the vertex shader.
gl.shaderSource(vertexShader, vertexShaderSource);

// Compile the vertex shader.
gl.compileShader(vertexShader);

// Check for compilation errors.
if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
  // If there's an error, log it to the console.
  console.error(gl.getShaderInfoLog(vertexShader));

  // Stop program execution.
  throw new Error("Failed to compile the vertex shader.");
}

// Repeat for the fragment shader.
const fragmentShaderSource =
`#version 300 es

precision highp float;

out vec4 outColor;

void main() {
  outColor = vec4(0, 0, 0, 1);
}`;
const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, fragmentShaderSource);
gl.compileShader(fragmentShader);
if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
  console.error(gl.getShaderInfoLog(fragmentShader));
  throw new Error("Failed to compile the fragment shader.");
}

// Create the shader program.
const program = gl.createProgram();

// Attach the shaders to the shader program.
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);

// Link the shaders.
gl.linkProgram(program);

// Check for linking errors.
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  // If there's an error, log it to the console.
  console.error(gl.getProgramInfoLog(program));

  // Stop program execution.
  throw new Error("Failed to link the shader program.");
}
```

With Umbra, all of the above can be condensed into one line.

```js
const program = Program.fromSource(gl, vertexShaderSource, fragmentShaderSource);
```

Next: [Attributes](/webgl/attributes)

export default function applyLayout({ children }) { return (<MdxArticleLayout>{children}</MdxArticleLayout>); }

export async function getStaticProps() {
  return {
    props: {
      title: "What is WebGL?",
      description: "An introduction to the fundamental concepts of WebGL."
    }
  };
}
