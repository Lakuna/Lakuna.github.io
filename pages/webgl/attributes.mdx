import MdxArticleLayout from "../../components/MdxArticleLayout.tsx";
import CodePen from "../../components/CodePen.tsx";
import styles from "../../styles/mdx-article.module.scss";

# Attributes

Since WebGL runs on the GPU, data must be passed to the GPU in order to be used for rendering.
One way to pass data to the GPU is through *attributes*.

Attributes are a type of variable in a WebGL program which are used as inputs to the vertex shader.
Based on rules specified by the developer, each time the vertex shader is run, each attribute will read a certain amount of data from the buffer assigned to it.
As such, attributes are used to supply vertex-specific data to the shader program.

```glsl
#version 300 es

// Attributes are inputs to the vertex shader.
// The naming convention for attributes is camelCase prefixed by "a_".
in vec4 a_position;

void main() {
  gl_Position = a_position;
}
```

Once an attribute has been declared in a shader program, it can be accessed through the WebGL API by getting its *location*.
Umbra does this step automatically.

```js
const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
```

## Buffers

Attributes can only read data from arrays of binary data called *buffers*.
They differ from regular arrays only in that they store binary data.

```js
// Create a buffer.
const positionBuffer = gl.createBuffer();
```

In order to reference a buffer through the WebGL API, that buffer must be bound to a *binding point*.
Different binding points are used for different things.

```js
// The ARRAY_BUFFER binding point is used for most buffers.
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

// Now we can put data into the buffer by referencing ARRAY_BUFFER.
gl.bufferData(
  // Which buffer to use.
  gl.ARRAY_BUFFER,

  // The data to put into the buffer.
  // Since WebGL is strongly-typed, data must be supplied in the form of a TypedArray.
  // This example will draw one two-dimensional triangle.
  // Two dimensions per point times three points to draw one triangle equals six values.
  new Float32Array([
    0, 0, // First point at (0, 0).
    0, 0.5, // Second point at (0, 0.5).
    0.7, 0 // Third point at (0.7, 0).
  ]),

  // Hint to WebGL about how the data will be used.
  // This is used for optimization purposes internally.
  // In this example, the data will never be changed so STATIC_DRAW is proper.
  gl.STATIC_DRAW
);
```

With Umbra, all of the above can be condensed into one line.
```js
const positionBuffer = new Buffer(gl, new Float32Array([0, 0, 0, 0.5, 0.7, 0]));
```

## Vertex array objects

Since buffers contain binary data, WebGL needs some context in order to read data out of them.
After all of the necessary data has been put into buffers, a WebGL program can be told how to use those buffers through a *vertex array object* (*VAO*).
VAOs contain information like which buffer is supposed to be used for each attribute, and what type of data is stored in that buffer.

Each VAO represents one "thing" to be drawn by a shader program.
For example, imagine that you want to draw two shapes: one cube and one sphere.
A cube and a sphere are different shapes, so each one is made up of a different set of vertices.
In order to avoid writing multiple separate shader programs just to draw different shapes, you can instead make one VAO which uses a buffer containing the positions to make a cube, and another VAO which uses a buffer containing the positions to make a sphere.

```js
// Create the VAO.
const vao = gl.createVertexArray();

// Turn on each attribute so that they can accept data from buffers.
gl.enableVertexAttribArray(positionAttributeLocation);

// For each attribute, specify which buffer to use and how.
// The buffer is automatically determined to be whichever buffer is currently bound to ARRAY_BUFFER.
gl.vertexAttribPointer(
  // Which attribute to specify data for.
  positionAttributeLocation,

  // The number of components to get per iteration.
  // Since this example put two-dimensional data into the buffer, it pulls two-dimensional data out.
  2,

  // The type of data in the buffer.
  // FLOAT is proper here because the buffer was supplied data in the form of a Float32Array.
  gl.FLOAT,

  // Whether to normalize the data after pulling it from the buffer.
  false,

  // The number of bytes to move forward after each iteration.
  // This value is calculated automatically if set to 0.
  0,

  // The offset in bytes of the first element in the buffer.
  0
);
```

The VAO defined in the example above makes it so that `a_position` pulls tightly-packed non-normalized float data from `positionBuffer` in intervals of `2`.
With Umbra, all of the above can be condensed into a single line.

```js
const vao = new VAO(program, [new AttributeState("a_position", positionBuffer, 2)]);
```

The thing defined by the data stored in the buffers can be drawn by executing the appropriate draw method with the correct VAO active.

```js
// Activate the program that's used to draw the thing.
gl.useProgram(program);

// Activate the VAO of the thing.
gl.bindVertexArray(vao);

// Execute the draw method.
gl.drawArrays(
  // The type of primitive to draw.
  gl.TRIANGLES,

  // The number of vertices to skip.
  0,

  // The number of vertices to draw.
  // One triangle times three vertices per triangle equals three vertices.
  3
);
```

With Umbra, all of the above can be condensed into a single line.

```js
vao.draw();
```

## Indices

An important feature of VAOs is that they allow vertices to be reused by filling the *element array buffer* with *indices*.

Imagine that you want to draw a square, which has four vertices.
A square isn't a type of primitive, so it must be drawn with two triangles (six total vertices).
Those two triangles have two overlapping vertices, so they can be defined using only four vertices if you define indices.

```js
const positionBuffer = new Buffer(gl, new Float32Array([
  0, 1, // Vertex zero (top left; top middle of the screen)
  0, 0, // Vertex one (bottom left; center of the screen).
  1, 0, // Vertex two (bottom right; middle right of the screen).
  1, 1 // Vertex three (top right; top right of the screen).
]));

const indices = new Uint8Array([
  0, 1, 2, // The first triangle uses vertices 0, 1, and 2.
  0, 2, 3 // The second triangle uses vertices 0, 2, and 3.
]);

const vao = new VAO(program, [new AttributeState("a_position", positionBuffer, 2)], indices);
```

Next: [Uniforms](/webgl/uniforms)

export default function applyLayout({ children }) { return (<MdxArticleLayout>{children}</MdxArticleLayout>); }

export async function getStaticProps() {
  return {
    props: {
      title: "Attributes",
      description: "An introduction to buffers and WebGL attributes."
    }
  };
}
