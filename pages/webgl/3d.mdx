import MdxArticleLayout from "../../components/MdxArticleLayout.tsx";
import CodePen from "../../components/CodePen.tsx";
import styles from "../../styles/mdx-article.module.scss";
import "katex/dist/katex.min.css";

# 3D

Working with three dimensions in WebGL is almost the same as working with two dimensions.

## Orthographic 3D

An *orthographic* projection is way to draw 3D without regard to perspective.
The example below uses only topics that have been covered before, but with 3D position inputs instead of 2D.

<CodePen slugHash="oNqvKRG" className={styles["full-bleed"]} />

Notice that the back of the rotating shape shows through to the front.
One way to address this issue is to draw only front-facing triangles.
By default, a triangle is front-facing if its vertices go in a counter-clockwise direction (relative to the camera).

```js
gl.enable(gl.CULL_FACE);
```

<CodePen slugHash="zYWYryq" className={styles["full-bleed"]} />

Now that clockwise triangles are being culled, many of the triangles aren't displaying.
This is because they're passed to the buffer in the wrong order.
By fixing the data in the position buffer, all of the triangles can be made to display.

<CodePen slugHash="PoRoZvd" className={styles["full-bleed"]} />

Even with only front-facing triangles rendering, some triangles show up when they're behind others.
The solution to this issue is the *depth buffer*.
The depth buffer is used to remember the depth of a given pixel, so that WebGL can draw behind or in front of other pixels based on their distance from the camera.
The third ($z$) component of `gl_Position` is put into the depth buffer.
The depth buffer needs to be enabled before it can be modified:

```js
gl.enable(gl.DEPTH_TEST);
```

Just like the color buffer, the depth buffer needs to be cleared before drawing every frame.
With the WebGL API, this can be accomplished like this:

```js
gl.clearColor(0, 0, 0, 0);
gl.clearDepth(1);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
```

With Umbra, the third parameter of `clearContext` can be used to clear the depth buffer:

```js
clearContext(gl, new Color(0x000000), 1);
```

<CodePen slugHash="yLKLOBy" className={styles["full-bleed"]} />

## Perspective

*Perspective* is the idea that things that are farther away from the camera appear smaller.
WebGL automatically divides the value assigned to `gl_Position` by its fourth ($w$) component.
This is useful for applying perspective because dividing (or multiplying) a vector by a scalar is equivalent to a scale operation.
In other words, the fourth component of `gl_Position` can be used to apply perspective to a shape.

In the example below, the cube on the left uses an orthographic projection, and the cube on the right uses perspective.

<CodePen slugHash="XWEWVar" className={styles["full-bleed"]} />

## Cameras

Rather than move the cube to fit in the frustum of the camera (as demonstrated in the example above), it is more common to move the camera to view the cube.
To do this, we can make a camera matrix that can be transformed just like any other matrix.
Once the camera is in the desired state, a *view matrix* can be calculated by inverting the camera matrix.
The *projection matrix* (calculated using either the orthographic or perspective function described above) can then be multiplied by the view matrix to make a *view projection matrix*.
Finally, objects in the scene can be viewed using the camera by multiplying their transformation matrices by the view projection matrix.

<CodePen slugHash="ZExERyO" className={styles["full-bleed"]} />

Next: [Textures](/webgl/textures)

export default function applyLayout({ children }) { return (<MdxArticleLayout>{children}</MdxArticleLayout>); }

export async function getStaticProps() {
  return {
    props: {
      title: "3D",
      description: "An introduction to depth and the techniques used to draw three-dimensional objects in WebGL."
    }
  };
}
